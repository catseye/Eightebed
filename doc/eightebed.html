<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- encoding: UTF-8 -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>The Eightebed Programming Language</title>
  <!-- begin html doc dynamic markup -->
  <script type="text/javascript" src="/contrib/jquery-1.6.4.min.js"></script>
  <script type="text/javascript" src="/scripts/documentation.js"></script>
  <!-- end html doc dynamic markup -->
</head>
<body>

<h1>The Eightebed Programming Language</h1>

<p>Language version 1.1</p>

<h2>Abstract</h2>

<p>While discussing <a class="external" href="http://cyclone.thelanguage.org/">Cyclone</a>,
Gregor Richards stated that in order for a language
to support explicit <code>malloc()</code>ing and <code>free()</code>ing of
allocated memory, while also being safe (in the sense of not being able to execute
or dereference incorrectly-populated memory) would require that language to
either support garbage collection, or to not implement <code>free()</code>.
In his words:</p>

<blockquote><p>A C-like language which provides a true explicit free() cannot be safe.
(By "true" I mean that you can get that memory back in a later malloc().)
To be safe a language must either never free (which is bad) or be GC'd.
[C-like languages being] imperative languages with pointers at arbitrary data, where safety is
defined as not seeing that data as a different type.</p></blockquote>

<p><dfn>Eightebed</dfn> was designed as a counterexample to that claim.
Eightebed is a small, C-like language with explicit <code>malloc()</code>
and <code>free()</code>.  Memory is actually freed by <code>free()</code>
and might be re-allocated by a future <code>malloc()</code>.  Yet Eightebed
is a safe language, requiring only a modicum of static analysis and runtime support,
and in particular, it neither specifies nor requires garbage collection:</p>

<ul>
<li><dfn>Garbage</dfn>, reasonably defined as "any unreachable block of memory",
is disregarded and considered a memory leak, as is good and proper (or at least
accepted) in a language with explicit memory management; and</li>
<li>Nothing is collected in any way.</li>
</ul>

<h2>Without Loss of Generality</h2>

<p>We place some restrictions on Eightebed in order that our implementation of
a compiler and analyzer for it may be simplified.  These restrictions do not, we assert,
prevent the language from being "C-like", as it would be possible to extend the
language to include them; the only thing we would be adding if we were to do so
would be additional complexity in implementation.  These restrictions are:</p>

<ul>
<li>There are no functions in Eightebed.  Common functionality can be repeated
verbatim inline, and recursion can be replaced with <code>while</code> loops.</li>

<li>Pointers may only point to named types, not integers or other pointers, and
only structures may be named.  The effect of a pointer to an integer or pointer
may be easily achieved by pointing to a named structure which consists of only
an integer or pointer itself.</li>

<li>Structures may not contain structures.  Again, this can be easily simulated
by "flattening" the structure into a single structure with perhaps differentiated names.</li>
</ul>

<h2>Syntax</h2>

<h3>EBNF Grammar</h3>

<p>Note that where this grammar is a little weird, it is only to support
being fully LL(1) to ease parser construction.  Notably, the syntax to access
a member of a structure uses both square brackets around the structure
and a dot between structure and member.  Unlike C, there is no syntax like
<code>-&gt;</code> to dereference and access a member in one go; you need
to dereference with <code>@</code>, then access the member with <code>[].</code>.</p>

<pre>
Eightebed ::= {TypeDecl} {VarDecl} Block.
Block     ::= "{" {Stmt} "}".
TypeDecl  ::= "type" Name<sub>Type</sub> Type ";"
Type      ::= "int"
            | "struct" "{" {Decl} "}"
            | "ptr" "to" Type
            | Name<sub>Type</sub>.
Decl      ::= Type Name ";".
VarDecl   ::= "var" Decl.
Stmt      ::= "while" Expr Block
            | "if" Expr Block ["else" Block]
            | "free" Ref ";"
            | "print" Expr ";"
            | Ref "=" Expr ";".
Ref       ::= "[" Ref "]" "." Name
            | "@" Ref
            | Name.
Expr      ::= "(" Expr ("+"|"-"|"*"|"/"|"="|"&gt;"|"&amp;"|"|") Expr ")"
            | "malloc" Name<sub>Type</sub>
            | "valid" Expr
            | IntLit
            | Ref.
</pre>

<h3>Example Program</h3>

<pre>
type node struct {
    int value;
    ptr to node next;
};
var ptr to node jim;
var ptr to node george;
{    
    jim = malloc node;
    if valid jim {
        [@jim].value = (1 + 4);
        george = jim;
    }
    if valid george {
        print [@george].value;
    }
    free george;
    free jim;
}
</pre>

<h2>How it Works</h2>

<h3>Static Analysis</h3>

<p>Dereferencing a pointer <var>x</var> must only occur at the
safe start of the "then" part of an <code>if</code> statement whose
test condition consists only of the expression <code>valid <var>x</var></code>.
The <dfn>safe start</dfn> of a block is the set of statements preceding and
including the first assignment statement or <code>free</code>.  (This is on the
[admittedly somewhat pessimistic]
assumption that any assignment could invalidate <var>x</var>.)
(<em>New in 1.1</em>: the safe start must precede the first <code>free</code>
statement, to prevent creation of dangling aliased pointers.  Thanks Gregor!)
To simplify implementation, we limit <var>x</var> to a simple variable name
rather than a full expression.  (This too is without loss of generality, as it is a
simple matter to use a temporary variable to store the result of a pointer expression.)
Any attempt to dereference a pointer which
does not follow these rules is caught by the static checker and disallowed.</p>

<h3>Runtime Support</h3>

<p>Every pointer in the Eightebed language is implemented internally
as a structure of a <dfn>machine pointer</dfn> (obtained, for instance, by C's <code>malloc()</code>)
coupled with a boolean flag called <code>valid</code>.
When a chunk of memory is initially successfully allocated, <code>valid</code> is
set to true.  Freeing a pointer first checks this flag; freeing the
machine pointer is only attempted if <code>valid</code> is true.
In addition, just before freeing the machine pointer, we invalidate
all aliases to that pointer.  (Starting with the "root set" of the
program's global variables, we traverse all memory blocks reachable
by following valid pointers from them, looking for pointers which
match the pointer about to be freed; any we find, we set their <code>valid</code>
flags to false.)  After freeing a pointer, we set its <code>valid</code>
to false.</p>

<h3>Why this Works</h3>

<p>Because of the static analysis, it is not possible to dereference 
a pointer at a point in the program where we do not know for certain
that it is valid (i.e., it is not possible to dereference an invalid
pointer.)  Because of the runtime support, as soon as a pointer becomes
invalid, all aliases of it become invalid as well.  (All reachable
aliases, that is â€“ but if an alias isn't reachable, it can't be dereferenced
anyway.)  Add both of these together, and you get memory that can
leak without any risk of being reused.</p>

<p>And no, this isn't garbage collection, because (as stated already)
we don't care about garbage and we don't collect anything.  Yes, the
runtime support looks a bit like the mark phase of a mark-and-sweep
garbage collector, but even it has a different job: not marking everything
that is reachable, rather invalidating all aliases of a given pointer.</p>

<p>And finally, yes, I realize how little this proves.  Long live loopholes.</p>

<pre>
16:19:38 &lt;Gregor&gt; We implement this without a GC by stuffing most of a GC into the free function, thereby making it just as slow as a GC'd language with none of the advantages!
16:25:29 &lt;Gregor&gt; So yes, although you have managed to fit my requirements, I am wildly underwhelmed :P
</pre>

<h2>Reference Implementation</h2>

<p>Cat's Eye Technologies provides a cockamamie reference implementation of
Eightebed called <code>8ebed2c.py</code>.  Written in Python 2.6,
it compiles Eightebed code to C, and for convenience will optionally
compile that C with the C compiler of your choice and run the resulting
executable.</p>

<p><code>8ebed2c.py</code> ships with a fairly extensive (for a language
like this!) suite of test programs, which can of course double as example
sources; these can be found in the <code>eightebed.tests</code> module.</p>

<p>For an appreciation of just how cockamamie <code>8ebed2c.py</code> is,
run <code>8ebed2c.py --help</code> and read through the command-line options
it provides.</p>

<h2>Legal Issues</h2>

<p>The name Eightebed started life as a typo for the word "enlightened" made on an
iPhone by a mysterious individual known only as Alise.  (Well, perhaps not <em>only</em>.)
Alise has aggressively asserted her intellectual property rights by copyrighting
[<i>sic</i>] the name Eightebed.  Cat's Eye Technologies has pursued permission to use
the name for this language, only to be told that the procedure for obtaining such
permission "involves five yaks, a Golden toad that hasn't eaten for five days,
five boxes of antique confetti (not stripped of uranium), dye number 90 (blood green),
a very confused weasel, and three pieces of A4.15 paper."</p>

<p>Cat's Eye Technologies' legal-and-yak-husbandry team is currently investigating
the feasibility of this arrangement, and as of this writing, official permission is
still pending.  If complications persist, another, less contentious name
(such as "Microsoft Windows 7") may need to be chosen for this language.</p>

<pre>
17:52:08 &lt;alise&gt; cpressey: I request that all harm is done to animals in the making of this production.
</pre>

<h2>Future Work</h2>

<p><i>In which we reveal the outline of a grand plan for a blockbuster sequel to Eightebed which will never materialize</i></p>

<ul>
<li>To be titled <em>Eightebed: Ascension</em> or <em>Eightebed: Generations</em>.  At least, title should have
one of those bad-ass colons in it.  Possibly <em>Eightebed: Eightebed</em>.</li>
<li>To support functions, analysis of arbitrary expressions as the condition in an <code>if valid</code>,
pointers to unnamed types, structures which contain other structures, and all that other boring stuff that
we just said doesn't matter.</li>
<li>To have a literate specification written in SUPER ITALIAN, thus giving all programs the power of
UNMATCHED PROPHETIC SNEEZING.</li>
<li>To be co-authored with Frank Zappa (note: turns out Mr. Zappa is dead.  Maybe Tipper Gore instead?  Yes,
that should work.)</li>
<li><del>To include a garbage collector.</del></li>
<li>Puppets???</li>
</ul>

<p>Happy leaking!
<br />Chris Pressey
<br />September 1, 2010
<br />Evanston, IL
</p>

</body>
</html>
